# Backend Challenge - Arquitectura Hexagonal + CQRS

Sistema backend con Arquitectura Hexagonal, CQRS, multi-tenant y event sourcing construido con Go.

## ğŸ—ï¸ Arquitectura

- **Hexagonal (Ports & Adapters)**: Dominio independiente de frameworks
- **CQRS**: SeparaciÃ³n de escritura (commands) y lectura (queries)
- **Event-Driven**: RabbitMQ para eventos de dominio
- **Multi-tenant**: Aislamiento por tenant a nivel de aplicaciÃ³n
- **TDD**: Desarrollo guiado por tests con cobertura >80%

## ğŸ“ Estructura del Proyecto
```
backend-challenge-guinea/
â”œâ”€â”€ cmd/
â”‚   â”œâ”€â”€ api/          # Servidor HTTP (REST API)
â”‚   â””â”€â”€ consumer/     # Consumidor de eventos (proyecciones)
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ contexts/     # Bounded contexts (users, auth)
â”‚   â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”‚   â”œâ”€â”€ domain/           # Entidades, value objects, eventos
â”‚   â”‚   â”‚   â”œâ”€â”€ application/      # Casos de uso (commands, queries)
â”‚   â”‚   â”‚   â””â”€â”€ infrastructure/   # Adaptadores (PostgreSQL, HTTP)
â”‚   â”‚   â””â”€â”€ auth/
â”‚   â”‚       â”œâ”€â”€ domain/           # Sesiones, autenticaciÃ³n
â”‚   â”‚       â”œâ”€â”€ application/      # Login
â”‚   â”‚       â””â”€â”€ infrastructure/   # HTTP handlers
â”‚   â””â”€â”€ shared/       # CÃ³digo compartido entre contexts
â”‚       â”œâ”€â”€ domain/              # Events base, value objects
â”‚       â”œâ”€â”€ infrastructure/      # Config, logger, bus, middleware
â”‚       â””â”€â”€ logger/
â”œâ”€â”€ migrations/       # Migraciones SQL
â”œâ”€â”€ docs/            # DocumentaciÃ³n y ADRs
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Makefile
â””â”€â”€ .env.sample
```

## ğŸš€ Inicio RÃ¡pido

### Prerrequisitos

- Go 1.21+
- Docker y Docker Compose
- Make (opcional pero recomendado)

### InstalaciÃ³n

1. **Clonar el repositorio**
```bash
git clone https://github.com/ramiroschettino/backend-challenge-guinea.git
cd backend-challenge-guinea
```

2. **Configurar variables de entorno**
```bash
copy .env.example .env
# Editar .env si es necesario (los valores por defecto funcionan)
```

3. **Levantar todos los servicios**
```bash
make up
```

Esto va a:
- Levantar PostgreSQL
- Levantar RabbitMQ
- Ejecutar migraciones automÃ¡ticamente
- Iniciar la API en http://localhost:8080
- Iniciar el consumer de eventos

### Comandos Disponibles
```bash
make help              # Ver todos los comandos disponibles
make up                # Levantar servicios
make down              # Detener servicios
make logs              # Ver logs de todos los servicios
make logs-api          # Ver logs solo de la API
make logs-consumer     # Ver logs del consumer
make test              # Ejecutar tests
make test-coverage     # Ejecutar tests con reporte de cobertura
make migrate           # Ejecutar migraciones manualmente
make migrate-down      # Revertir Ãºltima migraciÃ³n
make clean             # Limpiar todo (containers, volumes, cache)
```

# ğŸ“¡ Endpoints

## Health Checks

### Verificar que la API estÃ¡ viva
```
GET http://localhost:8080/health
```

### Verificar que las dependencias estÃ¡n listas
```
GET http://localhost:8080/ready
```

---

## Users API

### Crear Usuario

```
POST http://localhost:8080/api/v1/users

Headers:
Content-Type: application/json
X-Tenant-Id: tenant-1
X-Idempotency-Key: unique-key-123

Body:
{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "SecurePass123!",
  "display_name": "Johnny"
}
```

### Obtener Usuario

```
GET http://localhost:8080/api/v1/users/{user_id}

Headers:
X-Tenant-Id: tenant-1
```

---

## Auth API

### Login

**Paso 1: Primero crea un usuario**

```
POST http://localhost:8080/api/v1/users

Headers:
Content-Type: application/json
X-Tenant-Id: tenant-1

Body:
{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "SecurePass123!"
}
```

**Paso 2: Luego haz login**

```
POST http://localhost:8080/api/v1/auth/login

Headers:
Content-Type: application/json
X-Tenant-Id: tenant-1

Body:
{
  "email": "john@example.com",
  "password": "SecurePass123!"
}
```

**Respuesta:**
```json
{
  "token": "uuid-token-here",
  "user_id": "user-id-here",
  "expires_at": "2025-11-02T12:00:00Z"
}
```

### Headers Requeridos

- `X-Tenant-Id`: Identificador del tenant (requerido)
- `X-Correlation-Id`: ID de correlaciÃ³n para trazabilidad (opcional, se genera automÃ¡ticamente)
- `X-Idempotency-Key`: Clave de idempotencia para evitar duplicados (opcional)

## ğŸ§ª Testing

### Ejecutar todos los tests
```bash
make test
```

### Ejecutar tests con cobertura
```bash
make test-coverage
```

Esto genera un reporte HTML en `coverage.html`

### Ejecutar tests de un paquete especÃ­fico
```bash
go test -v ./internal/contexts/users/domain/...
go test -v ./internal/contexts/users/application/commands/...
go test -v ./internal/contexts/auth/application/commands/...
```

## ğŸ—„ï¸ Base de Datos

### Migraciones

Las migraciones se ejecutan automÃ¡ticamente al hacer `make up`.

**Crear nueva migraciÃ³n:**
```bash
make migrate-create NAME=add_user_status
```

**Ejecutar migraciones manualmente:**
```bash
make migrate
```

**Revertir Ãºltima migraciÃ³n:**
```bash
make migrate-down
```

### Esquema

- **users_write**: Tabla de escritura (write model)
- **users_read**: Tabla de lectura optimizada (read model / proyecciÃ³n)
- **idempotency_keys**: GestiÃ³n de idempotencia

## ğŸ° RabbitMQ

**Management UI**: http://localhost:15672
- Usuario: `guest`
- ContraseÃ±a: `guest`

### Eventos

- `user.created`: Se publica cuando se crea un usuario
  - El consumer escucha este evento y actualiza el read model

## ğŸ”§ ConfiguraciÃ³n

Todas las configuraciones se gestionan mediante variables de entorno (archivo `.env`).

Ver `.env.sample` para la lista completa de variables disponibles.

## ğŸ¯ Features

### Implementados

- âœ… Arquitectura Hexagonal (Ports & Adapters)
- âœ… CQRS (Command Query Responsibility Segregation)
- âœ… Event Sourcing con RabbitMQ
- âœ… Multi-tenant (X-Tenant-Id header)
- âœ… Idempotencia en comandos
- âœ… Rate limiting por tenant
- âœ… Feature flags por tenant
- âœ… Correlation ID para trazabilidad
- âœ… Logs estructurados (JSON)
- âœ… Health checks
- âœ… Migraciones automÃ¡ticas
- âœ… AutenticaciÃ³n bÃ¡sica (login)
- âœ… Tests unitarios (>80% cobertura en dominio)
- âœ… Docker & Docker Compose
- âœ… Graceful shutdown

### Multi-Tenant

Cada request debe incluir el header `X-Tenant-Id`. Los datos estÃ¡n aislados por tenant:
- Usuarios de `tenant-1` no pueden ver usuarios de `tenant-2`
- Rate limiting por tenant
- Feature flags por tenant

### Idempotencia

Los comandos soportan idempotencia mediante el header `X-Idempotency-Key`:
- Si envÃ­as el mismo comando con la misma clave 2 veces, solo se ejecuta una vez
- Ãštil para reintentos en caso de timeouts o errores de red

### Feature Flags

Ejemplo: `display_name` solo estÃ¡ habilitado para algunos tenants.

ConfiguraciÃ³n actual:
- `tenant-1`: âœ… display_name habilitado
- `tenant-2`: âŒ display_name deshabilitado

## ğŸ“Š Monitoreo

### Logs

Los logs estÃ¡n estructurados en formato JSON con campos:
- `level`: debug, info, warn, error
- `msg`: mensaje del log
- `correlation_id`: para seguir el flujo de una request
- `tenant_id`: identificador del tenant
- Campos custom segÃºn el contexto

**Ver logs:**
```bash
make logs              # Todos los servicios
make logs-api          # Solo API
make logs-consumer     # Solo consumer
```

## ğŸ”’ Seguridad

- ContraseÃ±as hasheadas con bcrypt (costo 10)
- ValidaciÃ³n de email
- PolÃ­tica de contraseÃ±as:
  - MÃ­nimo 8 caracteres
  - Al menos 1 mayÃºscula
  - Al menos 1 minÃºscula
  - Al menos 1 nÃºmero
  - Al menos 1 carÃ¡cter especial

## ğŸ—ï¸ Decisiones ArquitectÃ³nicas

Ver los ADRs (Architecture Decision Records) en `/docs/adr/`:
- [ADR-001: Arquitectura Hexagonal](docs/adr/001-hexagonal-architecture.md)
- [ADR-002: CQRS Pattern](docs/adr/002-cqrs-pattern.md)
- [ADR-003: Estrategia Multi-Tenant](docs/adr/003-multi-tenant-strategy.md)

## ğŸ“ˆ Diagramas

Ver [flujo de comandos y eventos](docs/diagrams/command-flow.md) para entender cÃ³mo fluye una request por el sistema.

## ğŸ› ï¸ TecnologÃ­as

- **Go 1.21+**: Lenguaje principal
- **Gin**: Framework HTTP
- **PostgreSQL 15**: Base de datos
- **RabbitMQ 3**: Message broker
- **Docker**: ContainerizaciÃ³n
- **golang-migrate**: Migraciones de DB
- **Zap**: Logger estructurado
- **Testify**: Framework de testing

## ğŸ“ Notas

- El proyecto sigue principios SOLID y Clean Architecture
- El dominio es completamente independiente de frameworks
- La separaciÃ³n CQRS permite escalar lectura y escritura independientemente
- Los eventos permiten eventual consistency entre write y read models
- El sistema estÃ¡ preparado para escalar horizontalmente

### Agregar nuevo contexto

1. Crear estructura en `internal/contexts/{nuevo_contexto}/`
2. Definir dominio (entidades, eventos, puertos)
3. Implementar casos de uso en application
4. Crear adaptadores en infrastructure
5. Registrar handlers y rutas

### Agregar nuevo caso de uso

1. Crear command/query en application
2. Implementar handler con tests
3. Crear endpoint HTTP en infrastructure
4. Documentar en README
